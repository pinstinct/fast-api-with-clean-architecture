## 데이터베이스 및 RabbitMQ 설정

```shell
cd script
docker-compose up -d 
```

## 앱 실행

```shell
python main.py
```

## Alembic

```shell
# 리비전 파일 자동 생성 
# -m 옵션: 메시지 작성
alembic revision --autogenerate -m "add User Table"

# 수행 (revision 파일의 upgrade 함수 실행)
# head 옵션: 가장 최신의 리비전 파일 수행 
alembic upgrade head

# 취소
alembic downgrade head
```

## 포맷팅

```shell
isrot .
autopep8 --in-place --aggressive --aggressive --recursive .
```

### pre-commit

```shell
pre-commit clean
pre-commit install --install-hooks
```

## 프로젝트 구조

### 아키텍처

- 관심사 분리와 계층형 아키텍처: 소프트웨어의 구성 요소들을 관심사에 따라 분리한다. 이는 네 개의 계층으로 나뉘어져 있다.
- 인터페이스 우선: 구성 요소들의 인터페이스를 먼저 정의해 사용한다. 세부 구현은 필요한 시점에 한다.
- 의존성 규칙: 클린 아키텍처의 핵심 원칙이다. 이 규칙에 따르면 소스 코드 의존성은 항상 외부에서 내부로 향해야 하며, 가장 중요한 코드(비즈니스 규칙)는 시스템의 중심에 있어야 한다.

#### 주요 4계층

(안)

- 엔티티 -> 도메인
- 유스 케이스 -> 애플리케이션
- 인터페이스 어댑터(컨트롤러, 게이트웨이, 프레젠터) -> 인터페이스
- 프레임워크 및 드라이버(장치, DB, 웹, UI, 외부 인터페이스) -> 인프라

(밖)

안으로 갈수록 고수준의 구성 요소가 된다. 고수준이란 더욱 추상화된 관점에서 문제를 해결하거나, 더 추상적이며 개념적인 관점을 의미한다.

##### 도메인(엔티티) 계층

- 도메인(domain): 애플리케이션이 해결하고자 하는 특정한 주제나 분야를 가리키며, 해당 분야에 적용되는 개념, 규칙, 데이터, 프로세스 등을 포함
- 저장소(repository): 외부 시스템인 데이터베이스에 저장하는 데이터 저장소를 기술하는 모듈
- 엔티티(entity): 비즈니스 도메인에서의 실제 개념이나 객체를 표현

##### 애플리케이션(유스 케이스) 계층

안쪽에서 두 번째 위치한다. 모든 소프트웨어 시스템은 그 애플리케이션이 해결하고자 하는 문제와 나름의 해결 방법을 가지고 있다. 이 계층에서는 그러한 특정 기능과 유스 케이스(use case)를 정의하고 구현한다.
따라서 로직이 가장 복잡하고 변경이 잦은 부분이다.

##### 인터페이스(인터페이스 어댑터) 계층

인터페이스 계층의 주요 특징

- 외부와 내부 사이의 데이터 변환
- 인터페이스 구현: 외부 시스템과의 통신을 담당한다.
- 외부 종속성의 분리

인터페이스 계층에는 컨트롤러, 게이트웨이, 프레젠터가 사용된다.

- 컨트롤러(controller): UI를 통해 전달된 사용자의 입력과 요청을 내부로 전달
- 게이트웨이(gateway): 외부 데이터 소스와의 통신을 담당 (외부 데이터베이스, API, 파일 시스템 등과의 상호작용 처리)
- 프레젠터(presenter): 내부 유스 케이스가 처리한 데이터를 전달받아 사용자가 볼 수 있는 형태로 가공해 UI로 전달

##### 인프라스트럭처(프레임워크 및 드라이버)

사용자 인터페이스, 디바이스, 웹 프레임워크, 데이터베이스 등과 같은 외부 환경과의 상호작용을 담당한다.

#### 의존관계 역전 원칙

각 계층의 구성 요소는 다른 계층의 구성 요소를 가져다 쓰게 된다. 즉, 의존성이 발생한다. 클린 아키텍처의 의존성 규칙은 그 의존성의 방향이 안으로 향하는 데에 있다.

### 의존성 주입

의존성 주입의 세 가지 유형

- 생성자 주입(constructor injection)
- 세터 주입(setter injection)
- 메서드 주입(method injection)

FastAPI는 엔드포인트 함수에 `Depends` 함수를 이용해 의존성을 주입할 수 있다. 그 외의 모듈에서 의존성을 주입하려면 의존성 프레임워크를 구현한 라이브러리를 활용해야 한다. 이 프로젝트에서는
`dependency-injector`를 이용했다.

### 기능

#### User 앱

- 회원 가입
- 로그인
- 유저 목록 조회
- 유저 정보 조회
- 유저 정보 수정
- 회원 탈퇴

#### Note 앱

- 노트 생성
- 노트 목록 조회
- 노트 정보 조회
- 노트 정보 수정
- 노트 삭제
- 태그 생성
- 태그 이름으로 노트 목록 조회

#### 미들웨어

- 유저 활동 로깅

#### 백그라운드 작업

- 환영 이메일 전송

## 비동기 프로그래밍

파이썬에서 동시성(병행성, concurrency)을 처리하는 방법은 여러 가지가 있다.

- 멀티스레딩(multithreading): 부모 프로세스의 메모리 콘텍스트를 공유해 여러 스레드를 실행한다. 입출력이 많이 수행되거나 사용자 인터페이스 응답성을 유지해야 하는 애플리케이션에서 효과적으로 작동한다.
  매우 경량이지만 사용 시 많은 주의가 필요하고, 메모리 안전에 위험성이 높다. `threading` 모듈을 사용해 스레드를 생성하고 관리할 수 있다. 각 스레드는 독립적으로 실행되며, 여러 작업을 동시에 처리할
  수 있다. 그러나 GIL로 인해 CPU를 주로 사용하는 작업에서는 실제로 동시성 향상이 일어나지 않을 수 있다.
- 멀티프로세싱(multiprocessing): 여러 작업(task)을 여러 독립된 프로세스에서 실행해 분산된 환경에서 작동하도록 한다. 동작 자체는 멀티스레딩과 유사하지만, 공유 메모리 콘텍스트에 의존하지 않는다.
  파이썬 특성상 CPU를 많이 사용하는 애플리케이션에 더 적합하다. 멀티스레딩보다 무거우며 프로세스간 통신 패턴을 구현해 프로세스들이 조화롭게 동작하도록 해야 한다. `multiprocessing` 모듈을 사용해
  구현할 수 있다.
- 비동기 프로그래밍(asynchronous programming): 여러 협력적 작업을 단일 애플리케이션 프로세스에서 실행한다. 협력적 작업들은 스레드처럼 동작하지만 작업 전환은 운영체제 커널이 아니라
  애플리케이션이 스스로 담당한다. I/O가 많은 애플리케이션, 특히 동시다발적인 네트워크 연결을 다루는 프로그램에 적합하다. 비동기 프로그래밍의 단점은 전용 비동기 라이브러리를 사용해야 한다는 점이다.

일반적으로 I/O 바운드 작업에는 비동기 프로그램이 유용하고, CPU 바운드 작업에는 스레드나 멀티프로세싱을 활용하는 것이 효과적이다.

동시성은 각 작업이 서로의 처리 순서나 결과에 영향을 미치지 않는 것을 의미한다. 이에 비해 병렬성(parallelism)은 여러 작업들을 병렬로 처리하는 것을 말한다. 따라서 동시성을 가지는 작업을 병렬처리 하면
작업 시간이 단축되고 처리 성능이 향상된다.

파이썬에서 병렬처리는 `concurrent.futures` 모듈을 사용해 처리할 수 있다.

## 백그라운드 작업

- 이메일 전송
- 파일 처리
- 알림 전송
- 외부 서비스와의 상호작용

### BackgroundTasks

FastAPI에서 제공하는 `BackgroundTasks` 클래스를 이용해 간단히 구현하는 방법이다. 엔드포인트 함수의 매개변수로 주입받아 사용하고 FastAPI가 나머지를 처리하도록 할 수 있다.

오래 걸리는 연산을 백그라운드에서 수행해야 하지만 동일한 프로세스에서 실행할 필요가 없는 경우(예를 들어, 메몰, 변수 등을 공유할 필요가 없는 경우)라면, 셀러리와 같은 다른 도구를 사용하는 것이 유용하다.
하지만 동일한 FastAPI 앱에서 변수와 객체에 접근해야 하거나, 이메일 알림 보내기와 같이 작은 백그라운드 작업을 수행할 때는 단순히 `BackgroundTasks`를 사용하는 것이 좋다.

### 셀러리

셀러리는 유닉스 시스템 기반의 분산 작업 큐(distributed task queue)로서, 비동기 작업을 처리하고 관리하는데 사용된다. 주로 백그라운드 작업을 처리하거나 스케줄링하고 분산 환경에서 작업을 실행한다.

메시징 시스템은 일반적으로 다음과 같은 특징을 지닌다.

- 작업 큐: 처리할 작업을 관리하는 큐를 제공한다. 작업은 큐에서 순서대로 처리될 수도 있고, 우선순위에 따라 조정될 수도 있다.
- 분산 환경: 여러 시스템 간에 작업을 분산해 처리할 수 있다.
- 작업 처리: 작업을 처리하기 위해 여러 워커(작업자)가 할당돼 동시에 작업을 수행한다.
- 메시지 브로커: 여러 응용 프로그램 또는 시스템 간에 작업을 전달하고 중개하는 역할을 한다.

셀러리 메시징 시스템은 다음 네 개의 구성 요소로 이루어진다.

- 브로커(broker): 셀러리에서 작업을 관리하고 전달하는 중간 매개체다. 메시징 시스템에서는 일반적으로 **메시지 브로커(message broker)**라고 부른다. 어떤 작업이 생성되고 완료될 때까지 그
  작업을 관리하고 전달하는 역할을 한다.
- 백엔드(backend): 작업의 결과를 저장하고 추적하기 위한 저장소다. 작업의 상태, 즉 작업 결과 및 성공 또는 실패 여부를 추적하는 데 사용된다.
- 워커(worker): 실제 작업을 수행하는 프로세스 또는 서버를 말한다. 워커는 브로커로부터 할당된 작업을 받아 실행하고, 실행 결과를 백엔드에 기록한다. 여러 대의 워커가 있으면, 작업은 이들 중 하나에 할당돼
  병렬로 처리된다.
- 태스크(task): 샐러리에서 수행되는 개별 작업을 나타낸다. 이는 보통 함수로 `@celery_app.task` 데커레이터로 구현한다.

브로커와 백엔드 역할을 하는 시스템으로서 레디스나 RabbitMQ 등을 활용할 수 있다.

#### 셀러리 워커 구동

만약 워커를 여러 개 생성하고 싶다면 새로운 창에서 각각 구동하면 된다.

```shell
celery -A common.messaging.celery worker -n worker1 --loglevel=info

# 워커 추가 
celery -A common.messaging.celery worker -n worker2 --loglevel=info
```

#### 파이썬 인터프리터에서 테스트

```shell
from example.celery_task import add
task1 = add.delay(1, 2)
task2 = add.delay(2, 3)
task1.result
task2.result
```

## 미들웨어(middleware)

HTTP 요청과 응답이 처리되기 전에 실행되는 함수를 말한다. 즉, HTTP 요청이 엔드포인트 함수로 전달되기 전이나, 응답이 외부로 반환되기 전에 실행된다. 예를 들면 다음과 같은 것들이다.

- 요청 데이터 처리
- 요청/응답 데이터 형식화
- 인증/인가
- 로깅 및 모니터링
- 캐싱
- 오류 처리
- API 속도 제한

FastAPI는 기본적으로 다음과 같은 미들웨어를 제공한다.

- CORSMiddleware
- GzipMiddleware: HTTP 응답을 Gzip으로 압축한다.
- HTTPSRedirectMiddleware: HTTP 요청을 HTTPS로 리디렉션한다.
- TrustedHostMiddleware: 특정 호스트에서만 요청을 허용한다.

그 외에도 다른 ASGI 미들웨어나 스탈렛이 제공하는 미들웨어를 사용할 수 있다.

> 주의사항: 주입된 의존성이 `yield`를 사용한다면 미들웨어 이후에 종료코드가 실행된다. 예를 들어 데이터베이스 연결을 닫거나 자원을 정리하는 코드가 있다면, 이 코드는 미들웨어가 수행된 후 실행된다.

`BackgroundTasks` 는 모든 미들웨어가 수행된 이후에 실행된다.

